"""
Building a Simple AI Agent, Part 3

Step 5: Update the Agent’s Memory

After executing an action, the agent updates its memory with the results. 

Memory serves as the agent’s record of what has happened during the interaction, including user requests, the actions 

performed, and their outcomes. By appending this information to the memory, the agent retains context, enabling it to 

 more informed decisions in future iterations.

In the code, memory is updated by extending it with both the LLM’s response (representing the agent’s intention) and the 

result of the executed action:

memory.extend([
    {"role": "assistant", "content": response},
    {"role": "user", "content": json.dumps(result)}
])

How This Works:

The assistant role captures the structured response generated by the LLM.

The user role captures the feedback in the form of the action result, ensuring that the LLM has a clear understanding of 

what happened after the action was performed. The results of actions are always communicated back to the LLM with the 
“user” role.

By keeping a running history of these exchanges, the agent maintains continuity, allowing it to refine its behavior 

dynamically as the memory grows and track the status of its work.

Step 6: Decide Whether to Continue

The final step in each iteration of the agent loop is determining whether to continue or terminate. This decision is 

based on the action executed and the state of the task at hand. If the parsed action specifies terminate, or if a 

predefined condition (e.g., maximum iterations) is met, the agent ends its loop.

In the code, this is implemented as a simple conditional check:

if action["tool_name"] == "terminate":
    print(action["args"]["message"])
    break
    
If the action specifies a termination, the loop exits, and the agent provides a closing message defined in the 

terminate action’s arguments. If no termination is triggered, the agent loops back to process the next user request or 

continue its task.

Example: Iterative Adaptation

Imagine the agent is tasked with reading a file but encounters a missing filename in the initial request.

In the first iteration, it executes list_files to retrieve the available files.

Based on the memory of this result, it refines its next action, prompting the user to select a specific file.

This iterative process continues until the task is completed or the agent determines that no further actions are required.

Each loop iteration, the agent can look back at its memory to decide if it has completed the overall task. 

The memory is a critical part of deciding if the agent should continue or terminate. By deciding whether to continue

 at each step, the agent balances its ability to dynamically adapt to new information with the need to eventually 

 conclude its task. The agent can also be instructed on when to terminate the loop, such as if more than two errors 
 
 are encountered or if a specific condition is met.



 Learning More & Staying Connected
If you haven't taken my first course,  
Prompt Engineering for ChatGPT
, it is a great complement to this course that also teaches concepts that every prompt engineer can benefit from.. 

Stay Up to Date in a Rapidly Changing AI Landscape — Join the Private Community for Professionals in My Coursera Classes

If you’re taking any of my Coursera courses, you’re invited to join our private Circle community!

 While the courses give you core skills and frameworks, this space is for going beyond the syllabus—with extra resources, 
 
 office hours, monthly updates on key trends in AI, and more. It also includes exclusive content that enriches and extends topics from all 20+ of my courses — and it’s only available to professionals actively taking my Coursera courses. It’s the best way to stay current, go deeper, and connect with others on the same professional learning journey. 

Join the Community:

https://generative-ai-innovation.circle.so/join?invitation_token=f63295a0efb682d1b4c12a5f7e8fe6772a3d348f-dc8fa7cc-6390-487e-bf8e-d16b6764f847

Connect with Me on LinkedIn

If you would like to stay connected to what we are doing at Vanderbilt as part of the Initiative on the Future of

 Learning & Generative AI, please don't hesitate to reach out and connect with me on LinkedIn:

https://www.linkedin.com/in/jules-white-5717655/

Learning More About Prompt Engineering

After this course (or concurrently), you can learn more about using ChatGPT and how to write effective prompts

 in my course on 

Prompt Engineering for ChatGPT
.

Learn More About Custom GPTs:

https://www.coursera.org/learn/openai-custom-gpts/

Learn More About ChatGPT Advanced Data Analysis:

https://www.coursera.org/learn/chatgpt-advanced-data-analysis

Primer on Generative AI
Learn how specifically Generative AI is going to transform computing and industry in 
my Generative AI Primer 
course. 

All My Generative AI Courses are Here

I teach a number of additional courses on Generative AI, including: GPT-4 Vision, Innovative Teaching with ChatGPT, 

ChatGPT Advanced Data Analysis, Generative AI Primer, Generative AI for Leaders, Trustworthy Generative AI, and more. 
You can see all the Generative AI courses that I teach here. 

Learn More Prompt Patterns in Our Paper:

A Prompt Pattern Catalog to Enhance Prompt Engineering with ChatGPT

Jules White, Quchen Fu, Sam Hays, Michael Sandborn, Carlos Olea, Henry Gilbert, Ashraf Elnashar, Jesse Spencer-Smith,

 Douglas C. Schmidt

Read a Paper on "Living Software Systems" and the future that AI Agents will make possible: 
https://arxiv.org/pdf/2408.01768





"""
from litellm import completion
from typing import List, Dict
import sys
import json
import warnings
warnings.filterwarnings("ignore", category=UserWarning, module="pydantic")

